# re2dot

根据正则表达式生成其对应 DFA 的状态转移图, 简单来说就是输入一个正则表达式, 然后会构造其对应的 NFA, 然后再构造对应的 DFA, 然后再最小化 DFA, 最后使用 [dot](http://graphviz.org) 语法绘制出最小 DFA. 

re2dot 使用姿势如下:

```
$ ./re2dot.py --help
usage: re2dot.py [-h] [-N] [-D] [-d] regexp

根据正则表达式生成其对应 DFA 的状态转移图

positional arguments:
  regexp         正则表达式

optional arguments:
  -h, --help     show this help message and exit
  -N, --nfa      若指定, 则输出原始 NFA 对应的状态转移图.
  -D, --dfa      若指定, 则输出原始 NFA 转换为 DFA 对应的状态转移图.
  -d, --minidfa  若指定, 则输出原始 NFA 转换为 DFA 并最小化后对应的状态转移图.
```

emmm.. 精力所限, 这里只支持闭包, 连接, 选择三种正则运算符. 据说剩余的正则运算符均可只用这三种运算符重写. 

```
$ ./re2dot.py 'a|(bc)*|def|((gh)*ij)*'
// Generated by hidva.com
digraph {
rankdir=LR
	0 [label="" peripheries=0]
	1 [peripheries=2]
	0 -> 1
	2 [peripheries=1]
	1 -> 2 [label=d]
	3 [peripheries=1]
	1 -> 3 [label=b]
	4 [peripheries=1]
	1 -> 4 [label=i]
	5 [peripheries=2]
	1 -> 5 [label=a]
	6 [peripheries=1]
	1 -> 6 [label=g]
	7 [peripheries=1]
	2 -> 7 [label=e]
	8 [peripheries=2]
	3 -> 8 [label=c]
	9 [peripheries=2]
	4 -> 9 [label=j]
	10 [peripheries=1]
	6 -> 10 [label=h]
	11 [peripheries=2]
	7 -> 11 [label=f]
	8 -> 3 [label=b]
	9 -> 4 [label=i]
	9 -> 6 [label=g]
	10 -> 4 [label=i]
	10 -> 6 [label=g]
}
```

```
$ ./re2dot.py -N 'a|(bc)*|def|((gh)*ij)*' | dot -Tsvg > imgs/nfa.svg
$ open imgs/nfa.svg
```

![abc](https://github.com/hidva/re2dot/blob/master/imgs/nfa.svg)

```
$ ./re2dot.py -D 'a|(bc)*|def|((gh)*ij)*' | dot -Tsvg > imgs/dfa.svg
$ open imgs/dfa.svg
```

![abc](https://github.com/hidva/re2dot/blob/master/imgs/dfa.svg)
